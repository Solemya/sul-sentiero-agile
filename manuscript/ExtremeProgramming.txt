# Extreme Programming

## Cosa è Extreme Programming
Extreme Programming (XP) è un framework agile dedicato allo sviluppo software, che definisce valori e pratiche volti alla produzione di codice di qualità.
A differenza di framework quali Scrum o Kanban, XP non si focalizza sul processo, bensì sulle pratiche ingegneristiche: questo fa sì che Scrum e XP, ad esempio, possano essere adottati allo stesso tempo (vedremo più avanti come questo connubio siano non solo fattibile, ma anche auspicabile).
XP si basa su cinque **valori**, quattordici **principi** e **ventiquattro pratiche** (tredici **pratiche** e undici **a corollario**); le fondamenta per attuare le pratiche XP sono quattro attività basilari del processo di sviluppo software: sviluppo del codice, sviluppo del test, ascolto e design.
Cosa caratterizza XP, secondo Kent Beck:
* I cicli brevi di sviluppo, che si traducono in un flusso di feedback continuo.
* L'approccio alla pianificazione incrementale: la definizione di un piano generale, che si evolve durante la vita del progetto.
* La capacità di pianificare l'implementazione di funzionalità  in modo flessibile, rispondendo alle mutevoli esigenze di business.
* Affidarsi a test automatici per monitorare i progressi dello sviluppo e consentire al sistema di evolvere e evidenziare i difetti in anticipo.
* La documentazione scritta è sostituita dalla comunicazione orale, dai test e dal codice.
* La consapevolezza che il design della soluzione evolve fintanto che il sistema vive.
* Fiducia nella collaborazione attiva di persone motivate.
* Si affida a pratiche che funzionano sia nelle dinamiche di team, che in quelle di progetto.

Vedremo di seguito perchè quando è efficace l'adozione di XP e il dettaglio di valori, pratiche e attività.

## Perchè XP
Extreme Programming è stato sviluppato da [Kent Beck](https://www.kentbeck.com/) (uno dei firmatari del Manifesto Agile) a partire dal 1996 ed è stato formalizzato per la prima volta dallo stesso Beck nel 1999 nel suo libro ['Extreme Programming Explained'](https://www.amazon.it/Extreme-Programming-Explained-Embrace-Change/dp/0201616416/ref=sr_1_4?adgrpid=52195471586&gclid=CjwKCAiA8ejuBRAaEiwAn-iJ3nL2YKKMSpv8GWJuONPUbyVXEqSKo-kI4mr-S-bzxhyKqjj5xHrAzBoC9YEQAvD_BwE&hvadid=255171266054&hvdev=c&hvlocphy=1008389&hvnetw=g&hvpos=1t1&hvqmt=e&hvrand=14148274798741980072&hvtargid=kwd-299811065929&hydadcr=18602_1737172&keywords=extreme+programming+explained&qid=1574595244&sr=8-4) (la seconda edizione del libro è disponibile su Amazon [QUI](https://www.amazon.it/Extreme-Programming-Explained-Embrace-Paperback/dp/B00M0O8952/ref=sr_1_1?__mk_it_IT=%C3%85M%C3%85%C5%BD%C3%95%C3%91&keywords=Extreme+Programming+Explained%3A+Embrace+Change%2C+2nd+Edition&qid=1574980117&sr=8-1)).
Nonostante il nome 'programmazione *estrema*', che potrebbe essere fuorviante, vedremo come le pratiche XP tendano principalmente a valutare massimizzare l'efficacia del prodotto nell'accogliere i cambiamenti dei requisiti e a rilasciare software con un rischio controllato.
Le condizioni nelle quali XP risulta particolarmente efficace possono essere riassunte come segue:
* Situazioni nelle quali i requisiti variano velocemente.
* Progetti con una data di scadenza stringente e un elevato rischio dovuto all'utilizzo di nuove tecnologie.
* Gruppi di sviluppi piccoli.
* Le tecnologie utilizzate permettono l'automazione di test di unità e test funzionali.

A [QUESTO](http://www.extremeprogramming.org/when.html) link potete trovare un'interessante approfondimento sul tema 'quando XP dovrebbe essere utilizzato'.
Da tenere in considerazione che, così come per Scrum, anche per XP avere dei team co-locati è senz'altro una caratteristica che ne facilita l'utilizzo e la pratica; d'altra parte questo non può essere considerato un vincolo ferreo, a nostro parere, dato che il mondo del lavoro sta sempre più accogliendo il remote working e le tecnologie, così come gli strumenti e i processi, stanno sempre più facilitando questo tipo di approccio.

Così come alcune condizioni esaltano l'efficacia di XP, altre la limitano fortemente; fra queste, vogliamo citarne un paio, non così inusuali:
* Sistemi nei quali i vincoli sugli scenari di utilizzo sono (volutamente o casualmente) laschi: in questi casi le condizioni di funzionamento del sistema non sono sempre note a priori e le casistiche di adozione (e do testing del sistema risultano impredicibili). Un esempio relativamente comune è l'integrazione fra due o più sistemi che non condividono interfacce con contratti specifici.
* Sistemi legacy instabili dove la complessità e il volume del codice comporterebbero un effort-XP smisurato rispetto alla banda a disposizione.

A [QUESTO](http://wiki.c2.com/?WhenIsXpNotAppropriate) link potete trovare un'interessante approfondimento sul tema 'quando XP non dovrebbe essere utilizzato'.


## Valori di Extreme Programming
Vediamo i cinque valori sui quali XP si basa:
* **Semplicità**: *faremo ciò che è necessario e richiesto, ma niente di più. Ciò massimizzerà il valore creato per l'investimento fatto fino ad oggi. Adotteremo piccoli e semplici passi verso il nostro obiettivo e mitigheremo i fallimenti man mano che si verificano. Creeremo qualcosa di cui siamo orgogliosi e lo terremo a lungo termine a costi ragionevoli* .
XP incoraggia ad iniziare sempre con la soluzione più semplice ed aggiungere funzionalità extra in un secondo momento. Una delle caratteristiche dell'approccio di Extreme Programming è la progettazione del software basata sulle esigenze contingenti, piuttosto che il design e l'architettura per il domani (spesso viene utilizzato l'acronimo YAGNI - You ain't gonna need it - ovvero - Non ne avrai bisogno -). Anche in XP troviamo più di una caratteristica che ricorda il principio del 'last responsible moment': è bene sottolineare che questo tipo di approccio comporta inevitabilmente un rework; la sua forza, d'altronde, è proprio quella di non ipotizzare soluzioni a lungo termine quando non abbiamo certezze (ricordiamo che una delle condizioni che massimizzano l'efficacia di XP è proprio un contesto con requisiti che cambiano frequentemente).
Tutto ciò ricorda molto il decimo principio agile: *Simplicity - the art of maximizing the amount of work not done - is essential*.

* **Comunicazione**: *tutti fanno parte del team e comunichiamo faccia a faccia ogni giorno. Lavoreremo insieme su tutto, dai requisiti al codice. Creeremo insieme la migliore soluzione al nostro problema* .
Una comunicazione efficace fra il team di sviluppo e gli stakeholder, ma anche all'interno del team favorisce le performance e la qualità del prodotto e, soprattutto, abbassa il rischio di divergenza fra le aspettative dei clienti e l'incremento di prodotto.
Tutto ciò ricorda molto il secondo valore agile (Customer collaboration over contract negotiation) e il seguente dei cinque valori di Scrum: *Apertura - I team di Scrum cercano costantemente nuove idee e opportunità di apprendimento. I team agili sono anche onesti quando hanno bisogno di aiuto*.

* **Feedback**: *ci impegneremo al massimo sul commitment di ogni iterazione, fornendo software funzionante. Portiamo in demo il nostro software il prima possibile e frequentemente, ascoltiamo i feedback attentamente e apportiamo di conseguenza le modifiche necessarie. Parleremo del progetto e vi adatteremo il nostro processo, non viceversa* .
Grazie ad un feedback frequente, il team può identificare le aree di improvement e rivedere le sue pratiche e i suoi processi. Il valore del Feedback è strettamente legato anche ai valori di Comunicazione e Semplicità: una comunicazione efficace e diretta esalta la qualità del feedback; un design semplice massimizza l'efficacia del feedback, permettendo una conversazione focalizzata.

* **Rispetto**: *ognuno di noi prova e dimostra all'altro il rispetto che merita, in quanto team member stimato. Tutti contribuiscono al valore, anche semplicemente con l'entusiasmo. Gli sviluppatori rispettano le competenze dei clienti e viceversa. Il management rispetta il nostro diritto di accettare la responsabilità e ricevere autorità sul nostro lavoro.

* **Coraggio**: *saremo onesti su progressi e stime. Non ci prepariamo delle scuse per eventuali fallimenti, perché intendiamo avere successo. Non temiamo nulla perché nessuno lavora mai da solo. Ci adatteremo ai cambiamenti ogni volta che accadranno*.
Come vedremo di seguito, più di una pratica incarna il valore del coraggio. Una di queste pratiche è quella di progettare e codificare sempre per l'oggi e non per il domani. Il coraggio consente essere confidenti con il refactoring del codice, quando necessario e permettere alle modifiche future di essere implementate più facilmente. Ancora: il coraggio è sapere quando eliminare il codice: rimuovere il codice sorgente che è obsoleto, non importa quanto sforzo sia stato fatto per creare quel codice sorgente. Inoltre, coraggio significa perseveranza: un programmatore potrebbe rimanere bloccato su un problema complesso per un giorno intero, quindi risolverlo rapidamente il giorno successivo, ma solo se si usa la perseveranza.

## Principi di Extreme Programming

## Pratiche di Extreme Programming
Le pratiche (o regole) di Extreme Programming dette 'primarie' possono essere adottate per iniziare ad applicare XP e miliorare il ciclo di sviluppo del software; l'ordine con il quale vengono messe in campo dipende dal contesto nel quale ci troviamo: potremmo aver  bisogno dapprima di migliorare la nostra fase di pianificazione, oppure potrebbe essere prioritario adottare le regole relative alla programmazione per migliorare migliorare la qualità del prodotto.

## Pratiche Primarie
### Sit Togheter
*Il team deve avere a disposizione un open space dedicato*: la comunicazione, uno dei cinque valori di XP è fondamentale per un team che lavora in Extreme Programming e, per migliorare l'efficacia della comunicazione, una delle più semplici ed efficaci azioni che si possono prendere è di mettere le persone nella situazione di poter comunicare senza barriere: si creeranno dei link che porteranno ad efficientare la comunicazione ed abbattere la burocrazia. Alcune possibilità sono: 
* Posizionare i computer in un'area comune: questo incoraggia e facilita il pair programming.
* Dedicare delle zone dell'open space ai meeting ricorrenti, come il daily stand up: aiuta le persone a non perdersi la riunione. 
* Posizionare dei tavoli per i meeting all'interno dell'open space: facilita le persone nell'organizzazione dei meeting e incoraggia ad allineamenti spontanei.
* Avere a disposizione delle whiteboard permette di ottenere dei meeting più efficaci e aiuta nell'allineamento aggiungendo il canale visivo alla comunicazione.  

### Whole Team
*Un team deve avere tutte le competenze necessarie per il successo del progetto*: questa è l'idea di cross-functional team, presente anche il altri framewor, come Scrum. Lo spirito di squadra e l'unione di intenti permette al team di essere resiliente e adattivo. Il team cresce e accresce le sue competenze coltivando la collaborazione e la cooperazione; il team può accogliere nuovi membri se servono nuove skill; se, invece, qualcuno dovesse risultare non più necessario, allora sarà per lui l'occasione di esserlo altrove.  
Un team di oltre dodici persone inizia ad essere disfunzionale a livello comunicativo: mantenere una dimensione adeguata del team è importante per massimizzarne l'efficacia. Ricordiamo che Scrum consiglia che la dimensione di un team sia non minore di tre persone e non maggiore di nove.

### Informative Workspace
*Lo spazio di lavoro deve rispecchiare il tuo lavoro*: un osservatore interessato dovrebbe essere in grado, attraversando il tuo workspace, di ottenere un'idea generale di come sta andando il progetto in quindici secondi. Molti team implementano (parzialmente) questa pratica utilizzando post-it e board cartacee attaccati al muro. L'ordinamento delle card trasmette, spazialmente, informazioni rapide.  
Lo spazio di lavoro deve anche fare attenzione ad altre necessità: avere a disposizione acqua e snack offre comfort e incoraggiare interazioni sociali positive. La pulizia e l'ordine lascia le menti libere di pensare ai problemi. Mentre la fase di programmazione viene svolta in open space, altri spazi separati potrebbero lasciare alle persone un po' di privacy, in orari dedicati.

### Energized Work
*Lavora solo quante più ore puoi essere produttivo e solo
quante ore riesci a sostenere*: andare in burnout e rendere improduttivi i prossimi giorni di lavoro non fa bene né alla persona, né al team. In un  progetto software non è difficile introdurre degli errori e smettere di produrre valore, ma quando si è stanchi è difficile saperlo riconoscere. Il consiglio è di non dedicare più tempo al lavoro, ma sfruttare meglio il tempo: ad esempio, potresti usare il seguente working agreement in due delle ore che quotidianamente dedichi allo sviluppo: spegni il telefono e le notifiche delle email, questo potrà portare già un miglioramento evidente.

### Pair Programming
*Scrivi il codice in coppia allo stesso PC*: una delle pratiche più note e più utilizzate di XP, il pair programming è un dialogo fra due persone che programmano simultaneamente, esaltando, in tal modo, le fasi di analisi, design e test.  
Il pair aiuta a chiarirsi le idee, facilita l'allineamento, esalta il principio della '[Collective Code Ownership](https://martinfowler.com/bliki/CodeOwnership.html)' e mantiene alta la produttività: quando una persona è confusa, o frustrata, l'altra persona della coppia prende l'iniziativa. Quando si è in una fase di prototipazione o di indagine e si ritiene più efficace lavorare da soli, magari in parallelo, lo si può fare; in un secondo momento ci si allinea con il team, mantenendo il focus più sull'idea, che sul codice: questo permette di non condizionare gli altri sulla specifica soluzione e mettersi nelle condizioni di poter evolvere il sistema in modo collaborativo.

### Pairing and Personal Space
*Tieni in considerazione che ogni persona ha una sensibilità diversa nell'utilizzo dello spazio fisico*: per alcune culture è più comune avere una prossimità fisica con il proprio interlocutore, in altri casi le persone sono più a loro agio mantenendo una maggiore distanza. Dobbiamo tenere in considerazione entrambi i casi per poter lavorare efficacemente con i nostri colleghi. Anche e soprattutto quando si lavora in pair, è fondamentale tenere in considerazione e rispettare le caratteristiche personali, dando la giusta attenzione ai segnali che le altre persone ti mandano.

### Stories
*Pianifica utilizzando funzionalità visibili all'utente*: svincolati dal significato di 'requisito' come work item richiesto, concentrati sul problema del cliente e trova una soluzione innovativa per risolverlo. 
Le User Story hanno tipicamente le seguenti caratteristiche:
* hanno una stima, data dal team, che indirettamente si riflette sull'effort necessario per sviluppare la funzionalità;
* hanno una descrizione breve;
* sono scritte su una card (solitamente in Post-it).

[Ron Jeffries](https://ronjeffries.com/xprog/articles/expcardconversationconfirmation/) ha formalizzato le caratteristiche di una User Story secondo le ormai note 3C:
* Card: le User Story sono scritte su Card, che contengono la descrizione dell'obiettivo, la priorità e la stima.
* Conversation: la richiesta della funzionalità (meglio: l'esplicitazione del problema) viene comunicata dal cliente al team di sviluppo attraverso una conversazione (in larga parte verbale).
* Confirmation: il cliente comunica al team quali Acceptance Test verranno usati per accettare la storia una volta terminata.

### Weekly Cycle
*Pianifica il lavoro una settimana alla volta*: durante questo meeting:
* Controlla il progresso del lavoro del team, in relazione a quanto pianificato
* Chiedi ai clienti di scegliere le storie da pianificare per la settimana successiva
* Suddividi le storie in task: i team member potranno committarsi sui task e stimarli.

Inizia la settimana scrivendo test automatici che verranno eseguiti quando
le storie sono completate. Con un ciclo di sviluppo così breve e con un piano di test pronto, dopo soli due giorni sarà facile capire se la pianificazione sarà rispettata o meno.  
Kent Beck punta molto sul valore di suddividere le storie in task, avere per ogni task il commitment e la stima di un team member; questo approccio tende a valorizzare il senso di ownership; Daniel Pink chiama questo aspetto 'Mastery', nel suo libro [Drive](https://www.danpink.com/books/drive).  

### Quarterly Cycle
*Pianifica il lavoro un trimestre alla volta*: ogni tre mesi rifletti sul team, sul progetto, sul suo progresso e sull'allineamento sui macro-obiettivi.  
Durante la pianificazione trimestrale:
* identifica i colli di bottiglia;
* avvia le azioni correttive
* pianifica le epiche del trimestre
* scegli le storie per indirizzare i Temi
* focalizzati sulla big picture, dove il progetto si inquadra all'interno dell'organizzazione.

Il trimestre è una scala temporale largamente utilizzata all'interno delle organizzazioni: questo aiuta a sincronizzarsi con altre attività di business dell'azienda e con i fornitori.
Differenziare i Temi (o Epiche) dalle storie serve anche a contrastare la tendenza dei team a concentrarsi sui dettagli, senza riflettere sul quadro generale. Inoltre i Temi sono estremamente utili per disegnare una roadmap.

### Slack
*Nei tuoi piani introduci delle piccole attività che possono essere eliminate se sei in ritardo*: è importante rispettare il commitment per coltivare un clima di fiducia; raggiungere pochi obiettivi concordati permettono di mantenere un rapporto saldo.  
Lo Slack time può essere strutturato in molti modi: possiamo pianificare una Geek Week, oppure riservare il 20% della banda a Spike e attività di innovazione.

### Ten-Minute Build
*Esegui la build del sistema e tutti i test in dieci minuti*: una build che impiega più di dieci minuti verrà eseguita molto meno spesso e perderai delle importanti opportunità per ottenere un feedback. Una build più breve non ti constringe a fare una pausa caffè nell'attesa. Un processo automatizzato di esecuzione della build e di tutti i test che impiega meno di dieci minuti mette nelle condizioni gli sviluppatori di potervi lavorare e apportare miglioramenti continuamente.

### Continuous Integration
*Integra e testa le modifiche dopo non più di un paio di ore*: la fase di integrazione è spesso imprevedibile: se non eseguito frequentemente, potrebbe richiedere più tempo di quello dedicato allo sviluppo.  
I modelli di integrazione possono essere sincroni (concludo le modifiche al codice, le integro, quindi vengono eseguiti i test e la build, ne attendo il termine e verifico che tutto sia corretto prima di ricominciare a programmare), oppure asincroni (integro le modifiche e ricomincio a programmare; i test e la build vengono eseguiti con un certo delay e vengo notificato dell'esito da una mail o una notifica su un radiator). Kent Beck consiglia di tendere verso l'integrazione sincrona, cosicché la coppia possa avere il tempo di riflettere su ciò che ha fatto, nel momento in cui l'ha fatto.

### Test-First Programming
*Scrivi un test automatico che fallisce prima di modificare qualsiasi codice*: il test-first programming indirizza diversi problemi in una sola volta: 
* Evoluzione minimale dello scope: dichiarando esplicitamente ciò che il programma dovrebbe fare, si evita di scrivere codice 'just in case', che potrebbe non servire, ma potrebbe comunque generare bug.
* Accoppiamento e coesione: se risulta difficile scrivere il test, questo è un segnale di un probabile problema a livello di design. Un codice è facilmente testabile se è liberamente accoppiato e molto coeso (Coesione significa che una classe dovrebbe rappresentare un unico concetto; Accoppiamento: una classe dipende da un'altra mentre usa gli oggetti della classe)
* Fiducia: scrivendo codice testato, aiuterete i vostri colleghi ad avere fiducia in voi e nel vostro codice.
* Ritmo: scrivere prima il test aiuta a essere focalizzati sull'obiettivo e non perdersi nella scrittura del codice.


### Incremental Design
*Investi del tempo ogni giorno nel design del sistema*: quando ci si rende conto che il design dovrebbe essere migliorato per adattarsi alle necessità del progetto, allora è opportuno lavorarci in modo iterativo e incrementale. Tieni sempre in considerazione il rapporto fra i costi dei cambiamenti (di design) e i costi dei bug. Tieni monitorato il tuo sistema e adattalo velocemente alle esigenze, evitare di arrivare nella situazione in cui il costo di un cambiamento sia drasticamente alto. L'indicazione che dà XP sul Design Incrementale (o emergente) non è che progettare in anticipo sia necessariamente un male, ma il design fatto vicino a quando viene utilizzato è più efficiente. Le best practice che esaltano il design emergente sono il riuso del codice e il continuo refactoring.

## Pratiche a corollario
Dopo aver messo in campo le pratiche primarie, è possibile focalizzarsi sulle pratiche a corollario; è importante rispettare l'ordine se si vogliono evitare dei possibili disastri.
Ad esempio: il Daily Deployment è una pratica che può essere messa in campo solo dopo aver lavorato sulla qualità e aver portato il rate dei difetti vicino allo zero, grazie alle pratiche primarie di Pair Programming, Continuous Integration e Test-First Programming.

### Real Customer Involvement
Rendi parte del team le persone che sono direttamente influenzate dal prodotto del team. Lascia che i clienti visionari diano il loro contributo durante i Planning trimestrali e quelli settimanali. Se riesci a rendere il prodotto del team veramente prezioso per il cliente, quest'ultimo pagherà pur di partecipare allo sviluppo. Mettendo insieme il cliente finale (chi ha un bisogno) e il team (chi può soddisfare questo bisogno), riuscirai a minimizzare gli sprechi e massimizzare il lavoro non svolto. L'impegno del team sarà quello di soddisfare il cliente con il minimo effort e cercare di mantenere il prodotto meno specifico possibile, in modo che possa soddisfare anche le richieste di altri clienti.








### Planning
*Si utilizzano le User Stories*: le User Stories (ne vedremo i dettagli in una sezione dedicata) sono simili agli Use Cases: vengono utilizzate per creare le stime per la pianificazione.
Le User Stories guidano anche la creazione dei test di accettazione: è necessario creare uno o più test di accettazione automatizzati per verificare che la User Story sia stata correttamente implementata.  
Uno dei maggiori fraintendimenti con le User Stories è il modo in cui differiscono dalle specifiche dei requisiti tradizionali: la più grande differenza sta nel livello di dettaglio, le User Stories dovrebbero fornire dettagli sufficienti per fare una stima (con un rischio ragionevolmente basso) di quanto tempo impiegherà la storia per essere implementata. Quando arriva il momento di implementare la storia, gli sviluppatori andranno al cliente e riceveranno una descrizione dettagliata dei requisiti faccia a faccia. Inizialmente le User Stories venivano stimate in settimane ideali di team (una settimana ideale è il tempo che si immagina ci vorrebbe per implementare quella storia se non si avesse nient'altro da fare); come sappiamo, questa unità di misura è stata ampiamente superata dagli Story Points.

*Il Release Planning crea il calendario di Release*: il piano di Release viene usato per creare i piani delle singole iterazioni. Per ottenere una pianificazione che rispecchi le priorità, è importante che le i tecnici prendano le decisioni tecniche e che le 'persone di business' prendano le decisioni di business. Esistono regole da rispettare durante il Release Planning meeting, che permettono di negoziare uno scheduling sul quale tutti possono impegnarsi:
* la stima delle storie è responsabilità dei tecnici
* la priorità delle storie è responsabilità del cliente

Le singole iterazioni sono pianificate in dettaglio poco prima dell'inizio di ogni iterazione e non in anticipo. L'incontro di pianificazione del rilascio è stato chiamato il gioco di pianificazione e le regole possono essere trovate al Portland Pattern Repository.
È possibile pianificare in base al tempo o allo scope: in entrambi i casi la Velocity del progetto viene utilizzata per determinare quante storie potranno essere implementate entro una certa data (pianificazione in base al tempo) o quanto tempo impiegherà lo sviluppo di una serie di storie (pianificazione in base allo scope).  
Una regola importante da tenere a mente è di non ristimare mai le storie per soddisfare il pressing del business: sottostimare una storia, causerà problemi in seguito.  
Inoltre è estremamente importante che vi sia un equilibrio fra la tensione tecnica e quella del business e che non vi sia sudditanza né in un verso, né nell'altro, per ottimizzare il processo di prioritizzazione.  
Un progetto può essere misurato secondo quattro variabili: 
* scope: può essere gestito dal business
* risorse: può essere gestito dal management
* tempi: definito dai tecnici
* qualità: non è contrattabile.

*Rilasciare frequentemente piccoli incrementi*: il team di sviluppo deve rilasciare frequentemente piccoli incrementi di valore al cliente, in modo iterativo(ogni settimana o due settimane). Alla fine di ogni iterazione, il prodotto sarà testato, funzionante e production ready.  
La pianificazione e la demo di piccoli incrementi di prodotto è fondamentale per ottenere feedback preziosi in tempo utile, ma la decisione di mandarli in produzione è del team (tenendo comunque in considerazione che: quanto prima si rilasciano in produzione i nuovi sviluppi, tanto prima otterremo i feedback e avremo più tempo per il fix di eventuali bug).

*Il progetto è strutturato in iterazioni*: lo sviluppo iterativo aggiunge agilità al processo di sviluppo; iterazioni di una settimana sono la scelta migliore anche se sembrano molto brevi. Mantenere costante la lunghezza dell'iterazione durante tutto il progetto è fondamentale sia per l'allineamento e l'organizzazione del team e con gli stakeholder, sia per avere consistenza nell'analisi delle metriche.  
Sebbene la pianificazione di Release sia spesso necessaria, la pianificazione just-in-time delle iterazioni permette di rimanere sincronizzato e recettivo con le mutevoli esigenze del cliente e del mercato.  
Il commitment sull'iterazione è una responsabilità forte che si prende il team: i progressi dello sviluppo durante un'iterazione devono essere costantemente monitorati e servono delle azioni specifiche e immediate di ripianificazione appena sia chiaro che il commitment non verrà raggiunto.  
All'interno dell'iterazione è importante rispettare le priorità date dal cliente e limitare il WIP.

*Ogni iterazione inizia con un planning*: la pianificazione dell'iterazione (che dura da 1 a 3 settimane) serve a produrre un piano di attività di per l'iterazione (priorità e effort). Le User Stories vengono scelte dal cliente partendo dal Release Planning; vengono inoltre selezionati i test di accettazione da correggere. Il cliente seleziona le User Stories ipotizzando una capacity uguale del team corrispondente alla velocity dello Sprint precedente.
Le User Stories (linguaggio del business) vengono dettagliate dal team in task (linguaggio tecnico).  
I singoli team member si committano su ogni singolo task e lo stimano (sempre in 1, 2, o 3 giorni ideali, o, come forse siamo più abituati a pensare, in Story Points), tenendo bene in considerazioni gli aspetti tecnici che nel mentre sono emersi, es: complessità architetturale, testing, refactoring.  
A questo punto la velocity di progetto viene nuovamente utilizzata per determinare se c'é over o under commitment e, eventualmente, aggiustare la pianificazione son l'aiuto del cliente.  

### Managing
*Mantenere un ritmo sostenibile*: i team XP hanno come vincolo quello di produrre entro fine iterazione del software potenzialmente rilasciabile in produzione (potentially shippable product increment), ovvero software completo, testato, integrato, production ready; ogniqualvolta si rilasci del software incompleto, aggiungiamo un rischio non calcolabile al sistema e un effort futuro non stimabile a priori. Poiché la qualità non è una variabile in gioco in XP, e l'over-commitment genera stress e riduce l'efficacia del team, è importante che il team trovi un ritmo sostenibile e si committi su una quantità di lavoro che può realisticamente portare a termine entro la fine dell'iterazione. Basarsi su un ritmo sostenibile, inoltre, aiuta a stabilizzare il rapporto velocity/commitment e rende la pianificazione (in particolare la fase di forecasting) più affidabile.

*Ogni giorno il team si allinea con un Daily Stand Up meeting*: il Daily Stand Up meeting (tipicamente svolto ogni mattina) viene utilizzato per comunicare problemi, soluzioni e aumentare il focus del team sul target dell'iterazione. Durante questo meeting, tutto il team sta in piedi in cerchio.
Durante il Daily Stand Up meeting, quello che spesso succede è che gli sviluppatori segnalano almeno tre cose; cosa è stato sviluppato ieri, cosa si intende sviluppare oggi e quali problemi stanno causando ritardi.

*La Velocity viene periodicamente misurata*: la Velocity, somma delle stime delle storie completate durante l'iterazione, è una misura di quanto lavoro viene svolto sul progetto. Questa misura è particolarmente utile durante il planning meeting, quando il cliente ipotizza una pianificazione a capacity equivalente alla velocity dell'iterazione precedente. Il team, dopo aver suddiviso le storie in task, potrà committarsi su un numero di task pari a quelli conclusi durante l'iterazione precedente e questo eventuale gap può portare ad una ripianificazione, fino ad arrivare ad un compromesso.  
Questo semplice meccanismo consente al team di non sovra-committarsi ed aggiustare la velocity dell'iterazione just in time, portando nel backlog eventuali nuove storie solo nel momento in cui ci sia la capacity.  
Qualora la velocity di un team inizi a stabilizzarsi in modo significativamente più basso rispetto alla media, è opportuno ripianificare la Release, anzichè attenderne il termine, e rivedere la priorità delle storie nel backlog.   Ogni team ha sensibilità e abitudini diverse nella stima delle storie: alcuni stimano alti, altri stimano bassi, questo ci dice che non è possibile fare confronti fra team sulle Velocity.

*Sposta le persone per creare knowledge sharing*: mantenere una stessa persona a lungo termine sullo stesso progetto o sulla stessa area funzionale o tecnica comporta un forte rischio di knowledge hoarding, o ancor peggio, di knowledge loss e determina, verosimilmente, dei colli di bottiglia che limitano l'efficienza di tutto il sistema.
La cross-contaminazione è fondamentale per evitare di creare isole di conoscenza: due metodi che posso aiutare a mitigare i rischi di cui sopra sono: spostare le persone sulla code base e applicare sistematicamente il pair programming.  
Una distribuzione delle competenze uniforme crea un efficace bilanciamento di carico all'interno del team e investire su questa cultura incoraggia tutti a provare a lavorare su nuove parti del sistema.

*Cambia il processo, se non funziona*: quando il processo XP, così come descritto, non funziona, modificalo in base alle specifiche necessità del tuo progetto. Inizia seguendo le regole XP, ma non esitare a cambiare ciò che non funziona.  
Le retrospettive, dove si parla di ciò che funziona e cosa no e si escogitano nuovi modi per migliorare XP rendono il miglioramento del processo una parte normale dello sviluppo. Ricordiamo la sezione del libro dedicata a SHI-HA-RI. 




## Risorse
link al podcast di Officina Agile
